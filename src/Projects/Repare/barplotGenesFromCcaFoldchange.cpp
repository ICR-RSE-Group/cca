//////////////////////////////////////////////////////////////////////////////
// MolBioLib: A C++11 framework for rapidly developing bioinformatics tasks //
// Copyright (C)  2019  Repare Therapeutics                                 //
//////////////////////////////////////////////////////////////////////////////


/** \file barplotGenesFromCcaFoldchange.cpp
 * Given a list of genes in an input file and a CCA-generated foldchange
 * file and CCA repmap input file(s), output barplots.
 */

// May want to either pass the compiler flag -DDEBUG and/or -DPROG_DEBUG or
// uncomment either or both of the below lines
// #define DEBUG
// #define PROG_DEBUG


#include "src/include/MolBioLib.hpp"


int main(int argc, char* argv[])
{

    BeginCommandArguments
    CommandArgumentBoolDefaultDoc("AT_HOME", AT_HOME, true, "If true, then all files are assumed to be in /home, so /home/ is prepended to the input and output.  For Docker version only.");
    CommandArgumentStringDoc("GENES", GENES, "Input file with header row and list of HUGO genes in some column.");
    CommandArgumentSize_tDefaultDoc("COLUMN", COLUMN, 0, "0-based index in which genes located in GENES file.");
    CommandArgumentSize_tDefaultDoc("NUM_GENES", NUM_GENES, numeric_limits<size_t>::max(), "Number of genes to get from GENES.   If unspecified, all genes.");
    CommandArgumentStringDoc("FOLDCHANGE", FOLDCHANGE, "A foldchange file of the form sgRNA name[tab] Gene [tab] sample1 [tab] sample2 [tab] ... like that generated by crisprCountsAnalysis.");
    CommandArgumentBoolDefaultDoc("OLD_FC", OLD_FC, false, "If true, the first column is gene and the second column is sgRNA in the FOLDCHANGE file.  This is to accomodate older input files.");
    CommandArgumentStringDoc("REPMAP", REPMAP, "CSV of files.  Same input as to crisprCountsAnalysis.cpp");
    CommandArgumentFileInDefaultDoc("BARPLOT_GENES_R", BARPLOT_GENES_R, "/root/src/Projects/Repare/barplotGenes.R", "R script to plot barplot.");
    CommandArgumentDoubleDefaultDoc("MIN", MIN, 0.0, "Start of y-axis");
    CommandArgumentDoubleDefaultDoc("MAX", MAX, 3.0, "End of y-axis");
    CommandArgumentDoubleDefaultDoc("BY", BY, 0.25, "Ticks spacing on y-axis");
    CommandArgumentBoolDefaultDoc("PLOT_DEPLETION", PLOT_DEPLETION, false, "If true, plot depletion instead.");
    CommandArgumentDoubleDefaultDoc("DEPL_MIN", DEPL_MIN, -3.0, "Start of y-axis");
    CommandArgumentDoubleDefaultDoc("DEPL_MAX", DEPL_MAX, 1.0, "End of y-axis");
    CommandArgumentBoolDefaultDoc("NEG_LOG2", NEG_LOG2, false, "If true, output -log2(value + EPSILON).");
    CommandArgumentDoubleDefaultDoc("EPSILON", EPSILON, numeric_limits<double>::min(), "Small value.");
    CommandArgumentBoolDefaultDoc("ADD_RANK", ADD_RANK, false, "If true, add gene rank to the output file name.");
    CommandArgumentStringDefaultDoc("OUT_HEAD", OUT_HEAD, "", "If specified, then output is OUT_HEAD.gene.png.  Otherwise output is FOLDCHANGE.gene.png.");
    EndCommandArguments

    if (PLOT_DEPLETION && NEG_LOG2) {
      cerr << "Error!  PLOT_DEPLETION=true and NEG_LOG2=true at the same time is not supported.  Exiting." << endl;
      exit(EXIT_FAILURE);
    }

    if (AT_HOME) {
      GENES = "/home/" + GENES;
      FOLDCHANGE = "/home/" + FOLDCHANGE;
      OUT_HEAD = "/home/" + OUT_HEAD;
    }

    if (OUT_HEAD == "") OUT_HEAD = FOLDCHANGE;

    vector<string> genes;
    unordered_set<string> check_genes;
    unordered_map<string, size_t> gene_rank;
    ReadOnlyTSVFile ifpG(GENES, true, true);
    for (size_t i = 1; !ifpG.fail() && i <= NUM_GENES; ++i) {
      ifpG.readRow(i);
      // The check_genes is just so we do not repeat any genes.
      if (check_genes.find(ifpG.tokens[COLUMN]) == check_genes.end()) {
        genes.push_back(ifpG.tokens[COLUMN]);
        gene_rank[ifpG.tokens[COLUMN]] = i;
        check_genes.insert(ifpG.tokens[COLUMN]);
      }
    }
    ifpG.close();

    unordered_map<string, bool> isControl;
    vector<string> repmaps;
    splitString(REPMAP, ",", repmaps, true);
    for (size_t k = 0; k < repmaps.size(); ++k) {
      if (AT_HOME) repmaps[k] = "/home/" + repmaps[k];
      if (fileSize(repmaps[k]) == static_cast<ifstream::pos_type>(-1)) {
        cerr << "Error!  REPMAP argument " << k << " = " << repmaps[k] << " does not exist.  Exiting." << endl;
        exit(EXIT_FAILURE);
      }
    }
    for (size_t k = 0; k < repmaps.size(); ++k) {
      ReadOnlyTSVFile ifpR(repmaps[k], true, true);
      for (size_t i = 1; !ifpR.fail(); ++i) {
        ifpR.readRow(i);
        string& sample_name = ifpR.tokens[0];
        if (ifpR.tokens[1] == "CTRL") {
          isControl[sample_name] = true;
        } else {
          isControl[sample_name] = false;
        }  
      }
      ifpR.close();
    } 

    //             gene                    sgRNA                 sample  value
    unordered_map< string,  unordered_map< string, unordered_map<string, string> > > foldchange;
    ReadOnlyTSVFile ifp(FOLDCHANGE, true, true);
    ifp.readRow(0);
    vector<string> header = ifp.tokens;
    for (size_t i = 1; !ifp.fail(); ++i) {
      ifp.readRow(i);
      for (size_t j = 2; j < ifp.tokens.size(); ++j) {
        if (!OLD_FC) {
          foldchange[ifp.tokens[1]][ifp.tokens[0]][header[j]] = ifp.tokens[j];
        } else {
          foldchange[ifp.tokens[0]][ifp.tokens[1]][header[j]] = ifp.tokens[j];
        }
      }
    }
    ifp.close();

    for (size_t i = 0; i < genes.size(); ++i) {
      Ofstream ofp(OUT_HEAD + ".barplotGenesFromCcaFoldchange.temp");
      if (!PLOT_DEPLETION) { 
        ofp << "Sample\tsgRNA\tFoldchange\tGroup" << endl;
      } else {
        ofp << "Sample\tsgRNA\tDepletion\tGroup" << endl;
      }
      string& gene = genes[i];
      for (auto j : foldchange[gene]) {
        string sgRNA = j.first;
        for (auto k : j.second) {
          string sample = k.first;
          string value = k.second;
          if (NEG_LOG2) {
            value = convertToString<double>(-1.0*log2(convertFromString<double>(value) + EPSILON));
          } else if (PLOT_DEPLETION) {
            value = convertToString<double>(1.0 - convertFromString<double>(value));
          }
          string ctrlString = "Test";
          if (isControl[sample]) ctrlString = "Control";
          ofp << sample << "\t" << sgRNA << "\t" << value << "\t"
              << ctrlString << endl;
        }
      }
      ofp.close();
      string out_file = OUT_HEAD + "." + gene + ".png";
      if (ADD_RANK) {
        out_file = OUT_HEAD + "." + convertToString<size_t>(gene_rank[gene]) + "." + gene + ".png";
      }
      if (PLOT_DEPLETION) {
        system("Rscript --vanilla \"" + BARPLOT_GENES_R + "\" \"" + OUT_HEAD + ".barplotGenesFromCcaFoldchange.temp\" \"" + out_file + "\" " + convertToString<double>(DEPL_MIN) + " " + convertToString<double>(DEPL_MAX) + " " + convertToString<double>(BY) + " Y");
      } else {
        system("Rscript --vanilla \"" + BARPLOT_GENES_R + "\" \"" + OUT_HEAD + ".barplotGenesFromCcaFoldchange.temp\" \"" + out_file + "\" " + convertToString<double>(MIN) + " " + convertToString<double>(MAX) + " " + convertToString<double>(BY) + " N");
      }
      system("rm \"" + OUT_HEAD + ".barplotGenesFromCcaFoldchange.temp\"");
    }


    return 0;
}

